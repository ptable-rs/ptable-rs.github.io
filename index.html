<!DOCTYPE html>
<html lang="en">

<head>
  <title>Pablo 11C237</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    .element-box {
      position: absolute;
      text-align: center;
      width: 50px;
      height: 50px;
    }

    .empty-space {
      position: absolute;
      width: 50px;
      height: 50px;
    }

    .big-square {
      position: absolute;
      font-weight: bold;
      width: 160px;
      height: 160px;
      background-color: rgba(0, 0, 0, 0.5);
      border: 2px solid black;
      z-index: 1;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      /* Align content to the left */
    }

    .symbol {
      margin-left: 10px;
      /* Add some space between the bigSquare and the symbol */
    }

    #hovered-element-display {
      position: absolute;
      background-color: rgba(255, 255, 255, 0.8);
      border: 1px solid #000;
      padding: 5px;
      display: none;
    }

    #hovered-element {
      font-size: 14px;
      color: rgb(0, 0, 0);
      padding: 10px;
      /* Add padding to prevent text from sticking to the edge */
    }

    #atom-model-container {
      position: absolute;
      top: 0;
      left: 350px;
      /* Adjust this value to position the model relative to the big square */
      width: 150px;
      /* Adjust the size of the container */
      height: 150px;
      /* Adjust the size of the container */
    }
  </style>
</head>

<body>
  <div id="ptable-canvas" style="position: relative; width: 100%;">
    <!-- Elements and spaces will be placed here -->
  </div>
  <div id="hovered-element-display"></div>
  <div id="atom-model-container"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const PTABLE_CONFIGURATION = [
      [true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true,],
      [true, true, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true,],
      [true, true, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true,],
      [true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,],
      [true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,],
      [true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,],
      [true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,],
      [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false,],
      [false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false,],
      [false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false,],
    ];

    const DATA_URL = 'https://raw.githubusercontent.com/orhnk/pablo/master/db/periodic-table-lookup.json';
    let ptable_db;
    fetch(DATA_URL)
      .then(response => response.json())
      .then(data => {
        ptable_db = data;
        renderElements();
      })
      .catch(error => {
        console.error('Error:', error);
        ptable_db = undefined; // Set ptable_db to undefined in case of error
      });

    function renderElements() {
      const ptableCanvas = document.getElementById('ptable-canvas');
      const hoveredElementDisplay = document.getElementById('hovered-element-display');
      const bigSquare = document.createElement('div');
      bigSquare.classList.add('big-square');
      bigSquare.style.display = 'none'; // Initially hide the big square
      ptableCanvas.appendChild(bigSquare);

      const hoveredElement = document.createElement('div');
      hoveredElement.id = 'hovered-element';
      bigSquare.appendChild(hoveredElement);

      // Create a div to display the symbol of the hovered element
      const hoveredElementSymbol = document.createElement('div');
      hoveredElementSymbol.classList.add('symbol');
      hoveredElementSymbol.id = 'hovered-element-symbol';
      hoveredElementSymbol.style.display = 'none'; // Initially hide the symbol
      bigSquare.appendChild(hoveredElementSymbol);

      let elementPositions = {}; // Object to store positions of elements
      let element_counter = 0;
      PTABLE_CONFIGURATION.forEach((row, rowIndex) => {
        row.forEach((isTrue, colIndex) => {
          if (isTrue) {
            const elem_name = ptable_db.order[element_counter++]; // Calculate symbol based on index
            const category = ptable_db[elem_name].category; // Get category information
            const elementBox = document.createElement('div');
            elementBox.classList.add('element-box');
            const element = document.createElement('p');
            element.textContent = ptable_db[elem_name].symbol; // Use symbol instead of direct name
            elementBox.appendChild(element);
            const leftOffset = colIndex * 60 + 20; // Adjust left offset based on column index
            const topOffset = rowIndex * 60 + 20; // Adjust top offset based on row index
            elementBox.style.left = leftOffset + 'px';
            elementBox.style.top = topOffset + 'px';
            elementBox.style.backgroundColor = getColorByCategory(category); // Set background color based on category
            ptableCanvas.appendChild(elementBox);
            // Store the position of the element
            elementPositions[elem_name] = {
              left: leftOffset,
              top: topOffset
            };
            // Add event listeners for mouseover and mouseout
            elementBox.addEventListener('mouseover', () => displayHoveredElement(elem_name));
            elementBox.addEventListener('mouseout', () => hideHoveredElement());
          } else {
            // Create an empty space
            const emptySpace = document.createElement('div');
            emptySpace.classList.add('empty-space');
            const leftOffset = colIndex * 60 + 20; // Adjust left offset based on column index
            const topOffset = rowIndex * 60 + 20; // Adjust top offset based on row index
            emptySpace.style.left = leftOffset + 'px';
            emptySpace.style.top = topOffset + 'px';
            ptableCanvas.appendChild(emptySpace);

            // Check if the empty space is between Hydrogen and Helium
            if ((colIndex === 0 && rowIndex === 0) || (colIndex === 1 && rowIndex === 0)) {
              bigSquare.style.left = leftOffset * 2 + 'px';
              bigSquare.style.top = topOffset * 1 + 'px';
            }
          }
        });
      });

      // Define function to get color based on category
      function getColorByCategory(category) {
        // Define color mappings for categories
        const colorMap = {
          'alkali metal': '#ff9999',
          'alkaline earth metal': '#ffcc66',
          'transition metal': '#99ccff',
          'post-transition metal': '#ffcc99',
          'metalloid': '#cc99ff',
          'polyatomic nonmetal': '#66cc99',
          'diatomic nonmetal': '#66cccc',
          'noble gas': '#cc99cc',
          'actinide': '#cc9999',
          'lanthanide': '#99cc99'
          // Add more categories and colors as needed
        };
        // Return the color for the given category, default to a fallback color if not found
        return colorMap[category] || '#cccccc';
      }

      // Define functions to display and hide the hovered element
      function displayHoveredElement(element_name) {
        hoveredElementDisplay.textContent = element_name;
        hoveredElementDisplay.style.display = 'block';
        const hoveredElement = document.getElementById('hovered-element');
        hoveredElement.textContent = element_name.toUpperCase(); // Set the symbol text
        const elementData = ptable_db[element_name]; // Retrieve data of the hovered element
        if (elementData) {
          const elementPosition = elementPositions[element_name];
          hoveredElementDisplay.style.left = elementPosition.left + 'px';
          hoveredElementDisplay.style.top = (elementPosition.top - 20) + 'px'; // Adjust position for better visibility
          hoveredElement.style.display = 'block'; // Show the big symbol
          bigSquare.style.backgroundColor = getColorByCategory(elementData.category); // Set background color based on category
          bigSquare.style.display = 'block'; // Show the big square
          hoveredElementSymbol.textContent = ptable_db[element_name].symbol; // Set the symbol text
          hoveredElementSymbol.style.display = 'block'; // Show the symbol
          renderAtomModel(ptable_db[element_name].bohr_model_3d);
        }
      }

      function hideHoveredElement() {
        hoveredElementDisplay.style.display = 'none';
        const hoveredElement = document.getElementById('hovered-element');
        hoveredElement.textContent = ''; // Clear the symbol text
        hoveredElement.style.display = 'none'; // Hide the big symbol
        bigSquare.style.display = 'none'; // Hide the big square
        hoveredElementSymbol.textContent = ''; // Clear the symbol text
        hoveredElementSymbol.style.display = 'none'; // Hide the symbol
        // Clear the atom model when hiding the hovered element
        document.getElementById('atom-model-container').innerHTML = '';
      }

      function renderAtomModel(modelUrl) {
        console.log('Model URL:', modelUrl); // Log the model URL to ensure it's correct
        const container = document.getElementById('atom-model-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const loader = new THREE.GLTFLoader();
        loader.load(
          modelUrl,
          function (gltf) {
            const model = gltf.scene;
            scene.add(model);
          },
          function (xhr) {
            console.log((xhr.loaded / xhr.total) * 100 + '% loaded');
          },
          function (error) {
            console.error('Error loading 3D model:', error);
          }
        );

        camera.position.z = 5;

        const animate = function () {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
        };

        animate();
      }

    }
  </script>
</body>

</html>